---
title: 1、动态代理
updated: 2021-10-07T21:18:14.0000000+08:00
created: 2021-06-03T14:19:40.0000000+08:00
---

一、什么是动态代理？
1.  代理
代购、中介、换ip、商家等等。

比如由一家美国的大学，可以对全世界招生，中介是学校的代理，中介代替学校完成招生功能。

代理特点：
1.  中介和代理他们要做的事情是一致的：招生。
2.  中介是学校代理，学校是目标。
3.  家长----中介（学校介绍，办入学手续）----美国学校。
4.  中介是代理，不能白干活，需要收取费用。
5.  代理不让你访问到目标。
为什么找中介？

1.中介是专业的，方便。

2.家长现在不能自己去找学校。家长没有能力访问学校。或者美国学校不接受个人来访。

3.还有一个例子：买东西都是商家卖，商家是某个商品的代理，你个人买东西，肯定不会让你接触到厂家的。
2.  在开发中也会有这样的情况，你有a类，本来是调用c类的方法，完成某个功能。但是c不让a调用。
a ---- 不能调用c的方法。

在a和c之间创建一个b代理，c让b访问。

a --访问b --访问c

实际的例子：登陆、注册有验证码，验证码是手机短信。中国移动，联通电信能发短信，他们不让个人发，而是让子公司或者关联公司面向社会提供短信的发送功能，张三项目发送短信 ----\> 子公司， 或者关联公司 ----\> 中国移动，联通，电信

3.  使用代理模式的作用
    1.  **功能增强**：在你原有的功能上，增加了额外的功能。
    2.  **控制访问**：代理类不让你访问目标，例如商家不让用户访问厂家
4.  实现代理的方式：
    1.  静态代理：
        1.  代理类时自己手工实现的，自己创建一个Java类，表示代理类
        2.  同时你所有代理的目标是确定的。
（咋这么像1）代表着抽象类，2）代表着抽象类实现的接口）
3.  特点：
    1.  实现简单。
    2.  容易理解。
    3.  耦合度过高。
    4.  当目标类增加了，代理类可能也需要成倍的增加。
    5.  当接口中功能增加了，会影响众多的实现类。
2.  动态代理：
    1.  在静态代理中目标类很多的时候，可以使用动态代理，避免静态代理的缺点。1）代理类数量可以很少。2）当你修改了接口中的方法时，不会影响代理类。
    2.  在程序的执行过程中，使用jdk的反射机制，并动态地指定要代理目标。换句话说，动态代理是一种创建java对象的能力，让你不同创建TaoBao（代理）类，就能创建代理类对象。
动态：在程序执行时，调用jdk提供的方法才能创建代理类对象。
3.  有什么用？
    1.  mybatis，spring
    2.  可以在不改变目标方法功能的前提下，可以在代理中增强自己的功能代码。例如： 在开发一个项目中，别人写了的类，我们需要使用，但有个方法功能不够，我们需要添加点功能，所以可以使用动态代理来实现增强。
4.  怎么实现：
    1.  jdk动态代理（理解）：使用java反射包中的类和接口实现动态代理的功能。反射包java.lang.reflect，里面有三个类，InvocationHandler，Method，Proxy
        1.  InvocationHandler接口：仅一个方法invoke()
            1.  invoke()：表示代理对象要执行的功能代码。你的代理类要完成的功能就写在这。
其完成的功能有：

1）调用目标方法，执行目标方法的功能

2）功能增强，在目标方法调用时增加功能

怎么用？

创建类实现InvocationHandler接口，实现invoke方法，将原来静态代理中代理类需要完成的功能写在这个方法体内
2.  Method类：表示方法，也有个invoke方法。执行Method代表的方法。具体的看JavaSE反射那块
3.  Proxy类：核心的对象，创建代理对象。之前创建对象都是new 构造方法()，现在我们是使用Proxy类的方法来代替new的使用——newProxyInstance() //是一个静态方法
    1.  public static Object newProxyInstance(ClassLoader loader, Class\<?\>\[\] interfaces, InvocationHandler h)
ClassLoader loader类加载器，负责向内存中加载对象，可以使用反射获取对象的ClassLoader类.getClass().getClassLoader()

Class\<?\>\[\] interfaces: 接口，目标对象实现的接口，也是反射获取的。

InvocationHandler： 我们自己写的代理类要完成的功能

**返回一个代理对象**

**然后通过这个代理对象执行需要执行的方法。**
2.  cglib（Code Generation Library）动态代理（了解）：cglib是一个第三方的工具库， 创建代理对象。
cglib的原理是继承目标类，创建它的子类，在子类中重写父类中同名的方法，实现功能的修改。

因为cglib是继承，重写方法，所以要求目标类不能是final的，方法也不能是final的。cglib的要求目标类比较宽松，只要能继承就可以，cglib在狠毒的框架中使用，比如mybatis，spring框架中都有使用。
3.  实现步骤：
    1.  创建接口，定义目标类要完成的功能，
    2.  创建目标类实现创建的接口
    3.  创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能
        1.  调用目标方法
        2.  增强功能
    4.  使用Proxy类的静态方法，创建代理对象。并把返回值转为**接口类型（很重要，自己试了没注意这里，就会ClassCastException）**。
    5.  然后通过这个对象来执行方法，执行方法的时候会去调InvocationHandler的invoke方法。
